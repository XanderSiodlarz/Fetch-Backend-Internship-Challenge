Part 2:
1) I chose to work based off the Flask framework because I have a strong background in python and while looking at the different frameworks it seemed that Flask was more straight to the point and offered a little more freedom than Django. 
Along with Flask, I chose to use SQLAlchemy for databases. I chose this because it comes hand in hand with Flask, as well as the fact that I can have the library do most of the work for me, not needing to utilize SQL a whole lot myself for this task. 
Furthermore, I used Marshmallow to help with serialization, which particularly came in handy with the spend and balance end points, as well as working nicely with Flask and SQLAlchemy.
Other libraries I utilized were request to take in POST requests, jsonify to organize my response bodies neatly in json format, and abort for potential error codes, such as code 400 for the spend endpoint.

2) While these tools work great together and offer a substantial amount of freedom, I have also found that there may be better frameworks that could make apis like this more scalable, especially when it comes to doing this for multiple users. However, being relatively small in scale, Flask benefits with its less rigid structure, as I can install or add additional modules along the way instead of having them all to begin with, with some being useless to this specific task. Another disadvantage is the Flask defaults to port 5000. This took a bit of trouble getting around as a couple of ways wouldn't work when I specified port 8000, however I found the command 'flask run --port 8000' to be the best to run the code.
While I decided to keep the code in one file, I think that growing this program on a larger scale would benefit from separating some of the code into multiple files, specifially some of the database models and serialization classes. All in all, however, I think with documentation, a single file can keep this project compact and to the point.

3) My favorite project so far has probably been a matrix multiplication / chain multiplication coding assignment. In an algorithms class, we were given the task to implement five different algorithms that all multiplied matrices and then run them against each other to see the time complexities live. Additionally, we had to combine and implement multiple algorithms to come to a solution for a chain matrix multiplication algorithm. 
This was my favorite because it was a challenge. It introduced a lot of new things to me, made me become more familiar with python and jupyter notebooks, and felt like I was solving a puzzle, putting the program together piece by piece. The most challenging part of it was the time. We were not given much time to complete this assignment, which made me really have to think and get reaquainted with the tools and language fast. Looking back, however, this definitely helped me by increasing my problem solving skills, especailly under the pressure of time.
